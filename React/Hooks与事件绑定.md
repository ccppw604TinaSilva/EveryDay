# Hooks与事件绑定
在`React`中，我们经常需要为组件添加事件处理函数，例如处理表单提交、处理点击事件等。通常情况下，我们需要在类组件中使用`this`关键字来绑定事件处理函数的上下文，以便在函数中使用组件的实例属性和方法。`React Hooks`是`React 16.8`引入的一个新特性，其出现让`React`的函数组件也能够拥有状态和生命周期方法。`Hooks`的优势在于可以让我们在不编写类组件的情况下，复用状态逻辑和副作用代码，`Hooks`的一个常见用途是处理事件绑定。

## 描述
在`React`中使用类组件时，我们可能会被大量的`this`所困扰，例如`this.props`、`this.state`以及调用类中的函数等。此外，在定义事件处理函数时，通常需要使用`bind`方法来绑定函数的上下文，以确保在函数中可以正确地访问组件实例的属性和方法，虽然我们可以使用箭头函数来减少`bind`，但是还是使用`this`语法还是没跑了。

那么在使用`Hooks`的时候，可以避免使用类组件中的`this`关键字，因为`Hooks`是以函数的形式来组织组件逻辑的，我们通常只需要定义一个普通函数组件，并在函数组件中使用`useState`、`useEffect`等`Hooks`来管理组件状态和副作用，在处理事件绑定的时候，我们也只需要将定义的事件处理函数传入`JSX`就好了，也不需要`this`也不需要`bind`。

那么问题来了，这个问题真的这么简单吗，我们经常会听到类似于`Hooks`的心智负担很重的问题，从我们当前要讨论的事件绑定的角度上，那么心智负担就主要表现在`useEffect`和`useCallback`以及依赖数组上。其实类比来看，类组件类似于引入了`this`和`bind`的心智负担，而`Hooks`解决了类组件的心智负担，又引入了新的心智负担，但是其实换个角度来看，所谓的心智负担也只是需要接受的新知识而已，我们需要了解`React`推出新的设计，新的组件模型，当我们掌握了之后那就不会再被称为心智负担了，而应该叫做语法，当然其实叫做负担也不是没有道理的，因为很容易在不小心的情况下出现隐患。那么接下来我们就来讨论下`Hooks`与事件绑定的相关问题，所有示例代码都在`https://codesandbox.io/s/react-ts-template-forked-z8o7sv`。

## 事件绑定
使用`Hooks`进行普通的合成事件绑定是一件很轻松的事情，在这个例子中，我们使用了普通的合成事件`onClick`来监听按钮的点击事件，并在点击时调用了`add`函数来更新`count`状态变量的值，这样每次点击按钮时，`count`就会加`1`。

```js
// https://codesandbox.io/s/hooks-event-z8o7sv
import { useState } from "react";

export const CounterNormal: React.FC = () => {
  const [count, setCount] = useState(0);
  const add = () => {
    setCount(count + 1);
  };
  return (
    <div>
      {count}
      <div>
        <button onClick={add}>count++</button>
      </div>
    </div>
  );
};
```
这个例子看起来非常简单，我们就不再过多解释了，其实从另一个角度想一下，这不是很类似于原生的`DOM0`事件流模型，每个对象只能绑定一个`DOM`事件的话，就不需要像`DOM2`事件流模型一样还得保持原来的处理函数引用才能进行卸载操作，否则是卸载不了的，如果不能保持引用的地址是相同的，那就会造成无限的绑定，进而造成内存泄漏，如果是`DOM0`的话，我们只需要覆盖即可，而不需要去保持之前的函数引用。实际上我们接下来要说的一些心智负担，就与引用地址息息相关。

另外有一点我们需要明确一下，当我们点击了这个`count`按钮，`React`帮我们做了什么。其实对于当前这个`<CounterNormal />`组件而言，当我们点击了按钮，那么肯定就是需要刷新视图，`React`的策略是会重新执行这个函数，由此来获得返回的`JSX`，然后就是常说的`diff`等流程，最后才会去渲染，只不过我们目前关注的重点就是这个函数组件的重新执行。`Hooks`实际上无非就是个函数，`React`通过内置的`use`为函数赋予了特殊的意义，使得其能够访问`Fiber`从而做到数据与节点相互绑定，那么既然是一个函数，并且在`setState`的时候还会重新执行，那么在重新执行的时候，点击按钮之前的`add`函数地址与点击按钮之后的`add`函数地址是不同的，因为这个函数实际上是被重新定义了一遍，只不过名字相同而已，从而其生成的静态作用域是不同的，那么这样便可能会造成所谓的闭包陷阱，接下来我们就来继续探讨相关的问题。



## 每日一题

```
https://github.com/WindrunnerMax/EveryDay
```

## 参考

```
https://juejin.cn/post/7194368992025247804
https://juejin.cn/post/7098137024204374030
https://react.dev/reference/react/useCallback
```

