# React闭包陷阱
`React Hooks`是`React 16.8`引入的一个新特性，其出现让`React`的函数组件也能够拥有状态和生命周期方法，其优势在于可以让我们在不编写类组件的情况下，更细粒度地复用状态逻辑和副作用代码，但是同时也带来了额外的心智负担，闭包陷阱就是其中之一。

## 闭包
从`React`闭包陷阱的名字就可以看出来，我们的问题与闭包引起的，那么闭包就是我们必须要探讨的问题了。函数和对其词法环境`lexical environment`的引用捆绑在一起构成闭包，也就是说，闭包可以让你从内部函数访问外部函数作用域。在`JavaScript`，函数在每次创建时生成闭包。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。

为了定义一个闭包，首先需要一个函数来套一个匿名函数。闭包是需要使用局部变量的，定义使用全局变量就失去了使用闭包的意义，最外层定义的函数可实现局部作用域从而定义局部变量，函数外部无法直接访问内部定义的变量。从下边这个例子中我们可以看到定义在函数内部的`name`变量并没有被销毁，我们仍然可以在外部使用函数访问这个局部变量，使用闭包，可以把局部变量驻留在内存中，从而避免使用全局变量，因为全局变量污染会导致应用程序不可预测性，每个模块都可调用必将引来灾难。

```JavaScript
const Student = () => {
    const name = "Ming";
    const sayMyName = function(){ // `sayMyName`作为内部函数，有权访问父级函数作用域`Student`中的变量
        console.log(name);
    }
    console.dir(sayMyName); // ... `[[Scopes]]: Scopes[2] 0: Closure (student) {name: "Ming"} 1: Global` ...
    return sayMyName; // `return`是为了让外部能访问闭包，挂载到`window`对象实际效果是一样的
}
const stu = Student(); 
stu(); // `Ming`

```

实际开发中使用闭包的场景有非常多，例如我们常常使用的回调函数。回调函数就是一个典型的闭包，回调函数可以访问父级函数作用域中的变量，而不需要将变量作为参数传递到回调函数中，这样就可以减少参数的传递，提高代码的可读性。在下边这个例子中，我们可以看到`local`这个变量是局部的变量，`setTimeout`进行调用的词法作用域是全局的作用域，理论上是无法访问`local`这个局部变量的，但是我们采用了闭包的方式创建了一个能够访问内部局部变量的函数，所以这个变量的值能够被正常打印。如果我们类似于第二个`setTimeout`直接将参数传递也是可以的，但是如果我们在这里封装了很多逻辑，那么这个参数传递就变得比较复杂了，根据实际情况用闭包可能会更合适一些。

```js
const cb = () => {
  const local = 1;
  return () => {
    console.log(local);
  };
}

setTimeout(cb(), 1000); // 1
setTimeout(console.log, 2000, 2); // 2
```

我们可以再看一个例子，我们在写`Node`时可能会遇到一个场景，在调用其他第三方服务接口的时候会会被限制频率，比如对于该接口`1s`最多请求`3`次，此时我们通常有两种解决方案，一种方案是在请求的时候就限制发起请求的频率，直接在发起的时候就控制好，被限频的请求需要排队，另一种方案是不限制发起请求的频率，而是采用一种基于重试的机制，当请求的结果是被限频的时候，我们就延迟一段时间再次发起请求，可以用指数退避算法等方式来控制重试时间，实际上以太网在拥堵的时候就采用了这种方法，每次发生碰撞后，设备会根据指数退避算法来计算等待时间，等待时间会逐渐增加，从而降低了设备再次发生碰撞的概率。

在这里我们需要关注第二种方案中如何进行重试，我们在发起请求的时候通常会携带比较多的信息，比如`url`、`token`、`body`等数据进行查询，如果我们需要进行重试，那么肯定需要找个地方把这些数据存储下来以备下次发起请求，那么在何处存储这些变量呢，当然我们可以在`global/window`中构造一个全局的对象来存储，但是之前也提到过了全局变量污染会导致应用程序不可预测性，所以在这里我们更希望用闭包来进行存储。在下边这个例子中我们就使用了闭包来存储了请求时的一些信息，并且在重试时保证了这些信息是最初定义时的信息。

```js
const requestFactory = (url, token) => {
  return function request(){ // 假设这个函数会发起请求并且返回结果
    return { url, token };
  }
}

const req1 = requestFactory("url1", "token1");
console.log(req1()); // 发起请求 `{url: 'url1', token: 'token1'}`
console.log(req1()); // 重试请求 `{url: 'url1', token: 'token1'}`
const req2 = requestFactory("url2", "token2");
console.log(req2()); // 发起请求 `{url: 'url2', token: 'token2'}`
console.log(req2()); // 重试请求 `{url: 'url2', token: 'token2'}`
```

## 闭包陷阱
说到这陷阱，不由得想起来一句话，出门出门就上当，当当当当不一样，平时开发的时候可以说是一不小心就上当掉入了陷阱。那么我们这个陷阱是完全由闭包引起的吗，那肯定不是，这只是`Js`的语言特性而已，那么这个陷阱是完全由`React`引起的吗，那肯定也不是，所以接下来我们就要来看看为什么需要闭包和`React`结合会引发这个陷阱。

闭包
  词法作用域 
  回调 fn => fn this
  定义时确定作用域
闭包陷阱
  react渲染视图机制
  函数多次运行示例
  组件多次执行示例
  setTimeout问题
  useEffect问题
useRef
  存储变量
  useMemoizedFn

## 每日一题

```
https://github.com/WindrunnerMax/EveryDay
```

## 参考

```
https://juejin.cn/post/6844904193044512782
https://juejin.cn/post/7119839372593070094
http://www.ferecord.com/react-hooks-closure-traps-problem.html
```
