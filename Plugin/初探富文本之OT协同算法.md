# 初探富文本之OT协同算法
`OT`的英文全称是`Operational Transformation`，是一种处理协同编辑的算法。当前`OT`算法用的比较多的地方就是富文本编辑器领域了，常用于作为实现文档协同的底层算法，支持多个用户同时编辑文档，不会因为用户并发修改导致冲突，而导致结果不一致甚至数据丢失的问题。

## 描述
从名字就可以看出来，`OT`协同算法的重点在于操作`Operation`与转换`Transformation`，简单来说，操作`Operation`指明了所有的操作必须原子化，例如在第`N`个位置插入了某个字符，在第`M`个位置删除了某个字符，类似于这样的所有的操作必须能够原子化地表示，转换`Transformation`指明了所有的操作必须要有转换的方案，例如我在第`N`个位置插入了字符，你在`N+2`个位置同时插入了字符，假设我的操作比较靠前，由于需要同步操作，那么在我本地执行你的`Operation`时就必须将其转换，插入的位置就必须增加我插入字符的长度，这就是大概的`OT`所需要的条件，当然具体的算法要远远比这个复杂，并且存在例如同步调度、`Undo/Redo`、光标、稳定性、可溯源等等问题需要一并解决。本文不涉及具体的协同算法，只是探讨了`OT`协同算法的基本思路，当前也有比较成熟的`OT`协同框架例如`ShareDB`等，可以相对简单地接入，当然只是相对而言，成本也是不低的。  

在讨论具体的协同算法之前，我们探究一下为什么要有协同算法，如果没有协同算法的话会出现什么问题，以及具体会出现问题的场景。那么假如我们有一个在线的文档应用，而我们是一个团队，我们有可能对同一篇文档进行编辑，既然我们会同时编辑，那么就有可能产生冲突。假设文档此时的内容为`A`，此时`U1`和`U2`两位用户同时在编辑，也就是说这两位都是从文档的`A`状态开始编辑，当`U1`编辑完成之后，文档状态是`B`，`U1`对文档进行了保存，此时`U2`也写完了，文档状态是`C`，`U2`也对文档进行了保存，那么此时文档的状态就是`C`了，由`U1`编写的`A -> B`状态的内容修改便丢失了，为了解决这样的问题，通常有以下几个方案。

### 乐观锁
乐观锁，主要就是一种对比于悲观锁的说法，因为乐观锁的操作过程中其实没有没有任何锁的参与，严格的说乐观锁不能称之为锁。乐观锁总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，可能需要在更新的时候会判断一下在此期间别人有没有去更新这个数据提示一下，或者干脆不会给予任何的提示信息。

那么具体到文档编辑上边，我们可以乐观地认为永远不会有两个人同时编辑同一篇文档，现实中也可能有这种情况，比如团队中每个人只负责几篇文档，其他人不需要也没有权限去编辑自己负责之外的文档，那么基于这种要求，我们可以乐观地认为永远不会出现冲突的问题，那么自然也就不需要对文档的管理做任何限制了，只需要完整地提供编辑能力即可。

### 悲观锁
悲观锁，顾名思义是基于一种以悲观的态度类来防止一切数据冲突的方式，其以一种预防的姿态在修改数据之前把数据锁住，然后再对数据进行读写，在其释放锁之前其他的任何人都不能对数据进行操作，直到前面一个人把锁释放后下一个人才可对数据进行加锁，继而才可以对数据进行操作，通过这种方式可以完全保证数据的独占性和正确性。

那么具体到文档编辑上边，我们可以对同一篇文档的编辑操作权限进行加锁，这样就可以保证同一时间只有一个人可以对文档进行编辑，其他人只能等待，直到前面的人把文档编辑完成并且释放锁之后，下一个人才可以对文档进行编辑，当然也可以开一个口子允许强行抢占并且将被抢占者的现场存储下来，相当于将一个并发操作压成了线性操作，这样就可以通过独占的方式保证文档的正确性，避免文档的内容冲突与丢失。

### 自动合并
自动合并，文档内容自动合并以及冲突处理的方式也是一个可行的方案，类似于`Git`的版本管理思想，可以对提交的内容进行`diff`差异对比、`merge`合并等操作，也可以在出现无法解决的冲突时出现时交给用户主动处理，`GitBook`是采用这种方式解决冲突问题的。

### 协同编辑
协同编辑，可以支持多个用户同时编辑文档，不会因为用户并发修改导致冲突，而导致结果不一致甚至数据丢失的问题。协同编辑重点在于协同算法，主要有`Operational Transformation(OT)`与`Conflict-free Replicated DATA Type(CRDT)`两种协同算法。协同算法不需要是正确的，其只需要保持一致，并且需要努力保持你的意图，就是说协同算法最主要的目的是在尽可能保持用户的意图的情况下提供最终的一致性，重点在于提供最终一致性而不是保持用户的意图。当前石墨文档、腾讯文档、飞书文档、`Google Docs`都是基于`OT`协同算法的，`Atom`编辑器使用的是`CRDT`协同算法。


## OT协同算法
`Operational Transformation(OT)`协同算法的核心思想是将文档的每一次修改都看作是一个操作，然后将这些操作进行转换来合并，最终得到文档内容。`OT`算法的目的是在尽可能保持用户意图的情况下，保持文档的最终一致性，举个例子，当`A`和`B`同时在文档的`L`处插入了不同的字符，那么谁插入的字符在前协同算法并不关心，其只需要尽可能地根据一定策略例如逻辑上的时序来判断究竟是谁的字符在前，但是最终计算出的结果即究竟谁的字符在前并不影响协同算法，其关心的重点在于经过协同算法将用户产生的`Op`调度之后，在每个人面前呈现的文档内容是绝对一致的，这就是保持文档的最终一致性。从功能的角度上说，协同算法保证的是在多人同时在线编辑的情况下，由于每个人提交的内容是不一样的，就需要通过协同算法的调度，使得每个用户最终都能看到一样的内容。  

在了解`OT`协同算法之前，我们也可以了解一下`OT`协同算法与`CRDT`协同算法的主要区别。首先`OT`与`CRDT`都提供了最终一致性，这也是协同编辑的最终目标，但是这两种方案达成这一目标的方式不一样：

* `OT`操作转换通过操作`Operation`转换`Transformation`来做到这一点，终端所进行的操作`O`通过网络传输，其他终端在收到操作`O`后需要进行转换`T`，之后才可以应用到文档上，最基础的`OT`是通过转换索引位置以确保收敛。
* `OT`通常必须要有中央服务器进行协同调度。
* `OT`通过算法处理编辑冲突的问题，增加了时间复杂度。
* `CRDT`无冲突复制数据类型则是通过数据结构来做到这一点，`CRDT`有两种实现方式，基于状态的`CvRDT`收敛复制数据类型和基于操作的`CmRDT`可交换复制数据类型。`CvRDT`是将各个副本进行合并，进行多少次合并或以何种顺序进行合并并不重要，所有副本都会收敛。`CmRDT`则具有可交换的操作，因此无需转换操作即可正确应用这些操作。
* `CRDT`更适合分布式系统，可以不需要中央服务器。
* `CRDT`通过数据结构保证了编辑的无冲突，增加了空间复杂度。

### 基本原理

说回`OT`协同，我们从两者`A`、`B`同时编辑同一段文本的基本操作开始，探讨一下`OT`协同为了保持一致性究竟做了什么。描述一篇文档的方式有很多，最经典的`Operation`有`quill`的`delta`模型，通过`retain`、`insert`、`delete`三个操作完成整篇文档的描述，还有`slate`的`JSON`模型，通过`insert_text`、`split_node`、`remove_text`等等操作来完成整篇文档的描述。首先我们假设有一个加粗的操作`Bold(start, end)`，一个插入的操作`insert(position, content)`。

那么此时，我们假设原始文本为`12`，用户`A`、`B`分别进行了一个加粗操作一个插入操作。
* 用户`A`进行了一个`Bold(1, 2)`操作，`A`本地需要首先应用这个操作，由此`A`本地的文本是`(12)`，为了简单起见，加粗用`()`表示。
* 用户`B`同时也进行了一个`insert(2, "B")`操作，`B`本地需要首先应用这个操作，由此`B`本地的文本是`12B`。
* 此时需要同步`Operation`，用户`A`收到了用户`B`的`insert(2, "B")`操作，`A`从本地的`(12)`应用之后，得到了`(12)B`。
* 用户`B`收到了用户`A`的`Bold(1, 2)`操作，`B`从本地的`12B`应用之后，得到了`(12)B`。


看起来并没有发生任何冲突，`A`、`B`最终都获得了一致的文档内容`(12)B`，当然事情并没有那么简单，我们继续往下看看其他的情况。为了简单起见，我们假设目前的只有`insert(position, content)`这个操作，从定义也能够明显的看出来，这个函数的意思是在`position`处插入`content`文本。

那么此时，我们假设原始文本为`123`，用户`A`、`B`分别进行了一个插入操作。
* 用户`A`进行了一个`insert(2, "A")`操作，`A`本地需要首先应用这个操作，由此`A`本地的文本是`12A3`。
* 用户`B`同时也进行了一个`insert(3, "B")`操作，`B`本地需要首先应用这个操作，由此`B`本地的文本是`123B`。
* 此时需要同步`Operation`，用户`A`收到了用户`B`的`insert(3, "B")`操作，`A`从本地的`12A3`应用之后，得到了`12AB3`。
* 用户`B`收到了用户`A`的`insert(2, "A")`操作，`B`从本地的`123B`应用之后，得到了`12A3B`。

经过上述协同结果是，用户`A`看到的内容是`12AB3`，用户`B`看到的内容是`12A3B`，内容不一致，没有成功地保证最终一致性。那么根据`OT`的`Operational Transformation`这个名字，我们来看上边的协同，发现我们只是做了`Operation`的同步，并没有做`Transformation`去转换，所以我们这是一个不完整的协同，当然也就不能完整地覆盖各种`Case`。

我们再来看看上边的协同方法有什么问题，实际上我们只是对我们自己本地的内容应用了从其他位置同步过来的操作，而这个操作是失去了上下文`Context`的，具体来说，我们以`A`为例，当我们接受到`B`的`insert(3, "B")`操作时，这个`Op`实际上是在原始文本为`123`这个文本为上下文的基础上进行的`Op`，而此时我们本地的文本内容是`12A3`，而此时去执行`B`的`Op`就由于缺失了上下文而导致出现了问题，所以此时我们就需要`OT`的`Transformation`来将其进行转换，当协作者变更到来时，我们需要变换操作以适应当前上下文，才能直接应用，而调整的过程，则基于当前文档已经发生的变更来完成。

```
Ob' = OT(Oa, Ob)
Oa' = OT(Ob, Oa)
```

而由上边上下文的基本想法我们可以得到`OT`协同的基本思路是，将每个用户的操作都转换成相对于原始文本的操作，这样就可以保证最终一致性。具体来说，假设文档的初始状态为`S`，以同步时的`A`用户为例我们此时应用了`Oa`也就是`insert(2, "A")`这个操作，而此时恰好我们又收到了`B`的`Ob`也就是`insert(3, "B")`操作，那么我们此时要应用`Ob`的时候，就需要进行转换，也就是`Ob' = OT(Oa, Ob)`，注意此时我们是将`Oa`也作为参数传入了进去，也就是说此时我们是通过`Oa`与`Ob`来作为参数算出来`Ob'`的，那么也就是说我们此时的上下文为`S`，同理对于`B`来说我们进行`Oa' = OT(Ob, Oa)`计算要应用的`Oa'`时，所处的上下文同样也是`S`，那么这样就将操作转换成了相对于原始文本的操作了，从而得到一致性。换句话说，也可以这么理解，`Ob' = OT(Oa, Ob)`就相当于我们将原本已经执行的`Oa`撤销掉，然后结合`Oa + Ob`从来得到`Ob'`，将两者的`Op`结合起来再应用到`S`上，对于`Oa' = OT(Ob, Oa)`同理，那么此时无论`A`还是`B`执行的上下文都是`S`，从而得到一致性。

落实到具体实现上，我们需要定义一套算法来完成这个`Transformation`，下面我们就简单实现一下，在这里的实现很简单，因为我们定义的操作只有`insert`，假如是上文提到的`retain`、`insert`、`delete`三种操作来描述文档的话，就需要实现`3x3 = 9`种变换操作，在这里我们对于两个`insert`的位置进行变换，如果此时新来的`cur op`插入的位置是在先前的`pre op`之后的，那么说明在原来的内容上已经添加了内容，那么我们就需要将插入的位置后移`pre op`插入文本的长度。

```js
function transform(pre, cur) {
  // 在`pre`之后插入，需要向后移动`cur`作用的`position`
  if (pre.insert && cur.insert && pre.insert.position <= cur.insert.position) {
    return { 
        insert: { 
            position: cur.insert.position + pre.insert.content.length, 
            content: cur.insert.content 
        }
    };
  }
  // ...
  return cur;
}
```

此外还记得之前说的`OT`的最终目的是保持最终的一致性，那么落实到这里，假设我们的两个`insert`操作都是同时在`2`位置插入一个不同的字符，那么在变换的时候我们需要决定究竟是谁在前，因为这两个操作的时序是一样的，也就是说可以认为是同时发生的，那么就必须制定一个策略来决定谁的字符在前，那么我们就通过第一个字符的`ASCII`来决定究竟是谁在前，这只是一个简单的策略，也就是所谓的尽可能保持用户意图的情况下，保持文档的最终一致性。

```js
// 如果两个`insert`的位置相同，那么我们需要通过第一个字符的`ASCII`来决定谁在前
if(pre.insert.position === cur.insert.position) {
    if(pre.insert.text.charCodeAt(0) < cur.insert.text.charCodeAt(0)) {
        return { 
            insert: { 
                position: cur.insert.position + pre.insert.content.length, 
                content: cur.insert.content 
            }
        };
    }
    return cur;
}
// A: 12  insert(2, A) 12A   oa
// B: 12  insert(2, B) 12B   ob
// A: 12A insert(3, B) 12AB  ob'
// B: 12B insert(2, A) 12AB  oa'
```

应用上边的`transform`函数，我们可以再来看一下上边的例子。那么此时，我们假设原始文本为`123`，用户`A`、`B`分别进行了一个插入操作。
* 用户`A`进行了一个`insert(2, "A")`操作，`A`本地需要首先应用这个操作，由此`A`本地的文本是`12A3`，可以看作是`2`后边插入了`A`。
* 用户`B`同时也进行了一个`insert(3, "B")`操作，`B`本地需要首先应用这个操作，由此`B`本地的文本是`123B`，可以看作是`3`后边插入了`B`。
* 此时需要同步`Operation`，用户`A`收到了用户`B`的`insert(3, "B")`操作，经由变换`transform(insert(2, "A"), insert(3, "B")) = insert(4, "B")`，`A`从本地的`12A3`应用之后，得到了`12A3B`。
* 用户`B`收到了用户`A`的`insert(2, "A")`操作，经由变换`transform(insert(3, "B"), insert(2, "A")) = insert(2, "A")`，`B`从本地的`123B`应用之后，得到了`12A3B`。

我们最终`A`与`B`都得到了`12A3B`，完成了最终一致性的操作，这就是`OT`的基本原理，那么接下来这个典型的菱形示意图也就好理解了，

```
      S  
 Oa  / \  Ob
    /   \
    \   /
 Ob' \ /  Oa'
      T
```

### Ops
前边的例子是协同的双方只进行了一个`Op`，那么实际上我们平时写文档的时候，大概率是会有多个`Op`的，那么对于多个`Op`同时出现的情况，`OT`又应该如何处理。首先要明确一点，`OT`的核心思想是不变的，也就是`Operational Transformation`，那么对于多个`Op`，我们的核心关注点就应该在如何`transform`。另外在刚接触`OT`的时候，我有一个想法，既然是多个`Op`那么在传输的时候将其合并为一个`Op`就可以了，后来仔细想了一下这样是不行的，首先有些操作确实是可以合并的，比如在同一个位置增加了一些文字，那么这些操作都可以归并为`insert`，相当于延时收集一下操作，但是有些操作就是不能合并的，比如在`A`位置写了一些文字，又在`B`位置写了一些文字，这样显然是不能合并的，除非是把整篇文档发送出去，那这就是`State-based CRDT`的范畴了，此外这样会导致协同的基础也就是原子化的`Op`失效，原子化失效了后边的变换、逻辑时序就都会出问题，那这是肯定不行的。

回到对多个`Op`做`transform`的问题上，假如此时`A`做了`Oa1`与`Oa2`两个`Op`，假设我们此时是在`A`的同步过程，也就是`A`需要在当前的基础上应用`B`的`Op`，那么依照于前文的`Ob' = OT(Oa, Ob)`，我们用当前最新的`Oa2`作为参数进行变换，也就是即将要应用的`Ob' = OT(Oa2, Ob)`，那么此时我们可能会看出来问题，`Oa1`的`Op`信息丢失了，那么即将要`Ob'`有可能是错误的，而且我们此时要应用的上下文并不是文档的初始内容`S`，而是进行了`Oa1`操作之后的`S'`，这就使我们之前总结的方案出了问题，出现了内容的分叉。那么如何纠正这个问题呢，很简单，我们应该让`Ob`做两次变换，也就是说我们需要`Ob'' = OT(Oa2, OT(Oa1, Ob))`，这样才可以将上下文回归到`S`，才能获得可以立即应用的正确的`Op`操作。对于这个示例，其也可以用经典的棱形来表示，两个客户端需要关注最外层的两条线，其实也可以看出来当客户端的操作比较多的时候，菱形会无限拓展。

```
              S
        Oa1 /   \ Ob
           /     \ 
       /   \     /
  Oa2 / Ob' \   / Oa1'
      \     / 
  Ob'' \   / Oa2'
         T
```

那么我们不妨再总结一下，实际上两个`OP`在进行`transform`时，本质上就是一个`OP`向另一个`OP`问询信息，并且根据信息来调整自己，那么只有产生自相同上下文，彼此通信的空间信息才是彼此信赖、可理解的，也才敢使用彼此的信息调整自己。那么我们可以总结出来:
* 可以做变换的前提是即将要变换的两个参数应该是产生自同一上下文的，例如上边的`OT(Oa1, Ob)`，当`Ob'`产生之后，此时`Oa2`和`Ob'`都是经过了`Oa1`操作之后得到的，也同属于同一上下文，那么`OT(Oa2, Ob')`的变换操作也是可行的。
* 可以应用的前提是`Op`产生自同一上下文，例如上边的`Ob''`，即将应用时可以追溯到其产生的上下文的位置是`S`，也就是文档的初始状态，而产生`Oa1`和`Oa2`两个操作的初始状态也是`S`，那么应用`Ob''`的操作也是可行的。

那么假如例子再复杂一些，`A`与`B`分别都产生了两个`Op`，那么该如何处理呢，那么此时就是去查询，找到可以做`OT`的`OP`，逐个进行变换，直到`OP`变换到当前上下文可用。我们假设`S(x,y)`表示在位置`(x,y)`的文档状态，`x, y`分别表示`A, B`两个客户端的状态，`A(x,y)`表示客户端`A`在状态`S(x,y)`下产生的操作，`B(x,y)`表示客户端`B`在状态`S(x,y)`下产生的操作，那么:

```
S(x,y) x A(x,y) = S(x+1,y)
S(x,y) x B(x,y) = S(x,y+1)
```

* 文档的初始状态为`S(0,0)`。
* `A`执行了操作`A(0,0)`，状态更新为`S(1,0)`，再执行`A(1,0)`，状态更新为`S(2,0)`
* `B`执行了操作`B(0,0)`，状态更新为`S(0,1)`，再执行`B(0,1)`，状态更新为`S(0,2)`。
* 在`B`中，`A(0,0)`基于`B(0,0)`做`OT`，得到可在状态`S(0,1)`上应用的`A(0,1)`，可得`S(1,1)`。
* 在`B`中，`A(0,1)`基于`B(0,1)`做`OT`，得到可在状态`S(0,2)`上应用的`A(0,2)`，可得`S(1,2)`。
* 在`A`中，`B(0,0)`基于`A(0,0)`做`OT`，得到可在状态`S(1,0)`上应用的`B(1,0)`，可得`S(1,1)`。
* 在`A`中，`B(1,0)`基于`A(1,0)`做`OT`，得到可在状态`S(2,0)`上应用的`B(2,0)`，可得`S(2,1)`。
* 在`B`中，`A(1,0)`基于`B(1,0)`做`OT`，得到可在状态`S(1,1)`上应用的`A(1,1)`，可得`S(2,1)`。
* 在`A`中，`B(0,1)`基于`A(0,1)`做`OT`，得到可在状态`S(1,1)`上应用的`B(1,1)`，可得`S(1,2)`。
* 在`B`中，`A(1,1)`基于`B(1,1)`做`OT`，得到可在状态`S(1,2)`上应用的`A(1,2)`，可得`S(2,2)`。
* 在`A`中，`B(1,1)`基于`A(1,1)`做`OT`，得到可在状态`S(2,1)`上应用的`B(2,1)`，可得`S(2,2)`。

可以通过图来比较直观地观察两者究竟是如何进行的操作，当然实际上这也是多个菱形，只不过摆正了而已，两个客户端需要关注最外层的两条线。

```
S(0,0)  →  A(0,0)  →  S(1,0)  →  A(1,0)  →  S(2,0)
   ↓                     ↓                     ↓
B(0,0)                B(1,0)                B(2,0)
   ↓                     ↓                     ↓
S(0,1)  →  A(0,1)  →  S(1,1)  →  A(1,1)  →  S(2,1)
   ↓                     ↓                     ↓
B(0,1)                B(1,1)                B(2,1)
   ↓                     ↓                     ↓
S(0,2)  →  A(0,2)  →  S(1,2)  →  A(1,2)  →  S(2,2)
```

对于`A`、`B`双方，最终我们都得到了`S(2,2)`的状态，请注意我们在客户端的起始位置是`S(2,0)`与`S(0,2)`，所以我们不能在以`S(1,1)`为基准的基础上做`A(1,0)`与`B(0,1)`的`OT`，而我们实际应用的`Op`如下所示，其余的状态都只是中间状态。

```
A：
A(0,0) --> A(1,0) --> B(2,0) --> B(2,1)   
S(2,0) ο B(2,0) ο B(2,1) = S(2,1) ο B(2,1) = S(2,2)

B：
B(0,1) --> B(0,2) --> A(0,2) --> A(1,2)
S(0,2) ο A(0,2) ο A(1,2) = S(1,2) ο A(1,2) = S(2,2)
```


### 中央服务器

我们来思考一下为什么协同这么难以实现，究竟是什么造成的，那么我们来试想一下，假如我们利用中央服务器来将多个用户的操作强行指定成同步操作会怎么样。
时序

### 最后
* `Undo/Redo`。
* `CAP`理论。
* 光标同步。

成熟的框架， ot.js sharedb ot-json

## 每日一题

```
https://github.com/WindrunnerMax/EveryDay
```

## 参考

```
https://zhuanlan.zhihu.com/p/50990721
https://zhuanlan.zhihu.com/p/426184831
https://zhuanlan.zhihu.com/p/559699843
https://zhuanlan.zhihu.com/p/425265438
http://www.alloyteam.com/2020/01/14221/
http://www.alloyteam.com/2019/07/13659/
https://www.51cto.com/article/717595.html
http://operational-transformation.github.io/index.html
https://xie.infoq.cn/article/a6fad791493bf4f698781d98e
https://github.com/yoyoyohamapi/book-slate-editor-design
```
