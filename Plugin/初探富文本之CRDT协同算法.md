# 初探富文本之CRDT协同算法
`CRDT`的英文全称是`Conflict-free Replicated Data Type`，最初是由协同文本编辑和移动计算而发展的，现在还被用作在线聊天系统、音频分发平台等等。当前`CRDT`算法在富文本编辑器领域的协同依旧是典型的场景，常用于作为实现文档协同的底层算法，支持多个用户同时编辑文档，不会因为用户并发修改导致冲突，而导致结果不一致甚至数据丢失的问题。

## 描述
`Conflict-free Replicated Data Type`直译过来就是无冲突的复制数据类型，从名字可以看出来，`CRDT`的重点在于无冲突复制和数据类型，去掉定语的话就可以得到`CRDT`是一种数据结构，也就是说`CRDT`是通过数据结构来保证最终一致性的。在分布式系统中，不同节点之间的数据复制存在一致性问题即强一致性问题，`CRDT`是作为一种理论来指导如何将原有数据结构设计成在数据复制过程中通向最终一致性的一种新的数据结构。假设此时我们拥有多个副本或者操作，如果托管副本的计算机之间没有协调，此时进行合并的话则可能导致副本之间的不一致，这通常是无法解决的，当更新存在冲突时，要恢复一致性和数据完整性，可能需要部分甚至全部更新的删除。由此`CRDT`指导我们在有多个副本或者操作进行合并或者更新时，使得我们的数据能根据一定的规则自动合并、解决冲突，最终达到强一致性的效果。回到富文本协同上，文档协同编辑同样可以理解为分布式应用的一种，而`CRDT`通过数据结构的设计保证并发操作数据的最终一致性。简单来说，`CRDT`就是可以在网络中的多个终端上复制的数据结构，副本可以独立和并行地更新，不需要在副本之间进行协调，并保证不会有冲突发生，从而保证最终各个副本的内容一致。

在讨论具体的协同算法之前，我们探究一下为什么要有协同算法，如果没有协同算法的话会出现什么问题，以及具体会出现问题的场景。那么假如我们有一个在线的文档应用，而我们是一个团队，我们有可能对同一篇文档进行编辑，既然我们会同时编辑，那么就有可能产生冲突。假设文档此时的内容为`A`，此时`U1`和`U2`两位用户同时在编辑，也就是说这两位都是从文档的`A`状态开始编辑，当`U1`编辑完成之后，文档状态是`B`，`U1`对文档进行了保存，此时`U2`也写完了，文档状态是`C`，`U2`也对文档进行了保存，那么此时文档的状态就是`C`了，由`U1`编写的`A -> B`状态的内容修改便丢失了，为了解决这样的问题，通常有以下几个方案。

### 乐观锁
乐观锁，主要就是一种对比于悲观锁的说法，因为乐观锁的操作过程中其实没有没有任何锁的参与，严格的说乐观锁不能称之为锁。乐观锁总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，可能需要在更新的时候会判断一下在此期间别人有没有去更新这个数据提示一下，或者干脆不会给予任何的提示信息。

那么具体到文档编辑上边，我们可以乐观地认为永远不会有两个人同时编辑同一篇文档，现实中也可能有这种情况，比如团队中每个人只负责几篇文档，其他人不需要也没有权限去编辑自己负责之外的文档，那么基于这种要求，我们可以乐观地认为永远不会出现冲突的问题，那么自然也就不需要对文档的管理做任何限制了，只需要完整地提供编辑能力即可。

### 悲观锁
悲观锁，顾名思义是基于一种以悲观的态度类来防止一切数据冲突的方式，其以一种预防的姿态在修改数据之前把数据锁住，然后再对数据进行读写，在其释放锁之前其他的任何人都不能对数据进行操作，直到前面一个人把锁释放后下一个人才可对数据进行加锁，继而才可以对数据进行操作，通过这种方式可以完全保证数据的独占性和正确性。

那么具体到文档编辑上边，我们可以对同一篇文档的编辑操作权限进行加锁，这样就可以保证同一时间只有一个人可以对文档进行编辑，其他人只能等待，直到前面的人把文档编辑完成并且释放锁之后，下一个人才可以对文档进行编辑，当然也可以开一个口子允许强行抢占并且将被抢占者的现场存储下来，相当于将一个并发操作压成了线性操作，这样就可以通过独占的方式保证文档的正确性，避免文档的内容冲突与丢失。

### 自动合并
自动合并，文档内容自动合并以及冲突处理的方式也是一个可行的方案，类似于`Git`的版本管理思想，可以对提交的内容进行`diff`差异对比、`merge`合并等操作，也可以在出现无法解决的冲突时出现时交给用户主动处理，`GitBook`是采用这种方式解决冲突问题的。

### 协同编辑
协同编辑，可以支持多个用户同时编辑文档，不会因为用户并发修改导致冲突，而导致结果不一致甚至数据丢失的问题。协同编辑重点在于协同算法，主要有`Operational Transformation(OT)`与`Conflict-free Replicated DATA Type(CRDT)`两种协同算法。协同算法不需要是正确的，其只需要保持一致，并且需要努力保持你的意图，就是说协同算法最主要的目的是在尽可能保持用户的意图的情况下提供最终的一致性，重点在于提供最终一致性而不是保持用户的意图。当前石墨文档、腾讯文档、飞书文档、`Google Docs`都是基于`OT`协同算法的，`Atom`编辑器使用的是`CRDT`协同算法。

## CRDT协同算法
`Conflict-free Replicated DATA Type(CRDT)`协同算法的核心思想在于解决冲突，而在于构造一种数据结构来避免冲突，避免了冲突就可以直接进行合并，最终得到文档内容。`CRDT`协同算法的目的是在尽可能保持用户意图的情况下，保持文档的最终一致性，举个例子，当`A`和`B`同时在文档的`L`处插入了不同的字符，那么谁插入的字符在前协同算法并不关心，其只需要尽可能地根据一定策略例如时间戳来判断究竟是谁的字符在前，但是最终计算出的结果即究竟谁的字符在前并不影响协同算法，其关心的重点在于经过协同算法将用户产生的`Op`调度之后，在每个人面前呈现的文档内容是绝对一致的，这就是保持文档的最终一致性。从功能的角度上说，协同算法保证的是在多人同时在线编辑的情况下，由于每个人提交的内容是不一样的，就需要通过协同算法的调度，使得每个用户最终都能看到一样的内容。实际上在线文档本身就是一个数据一致性要求很强的项目，所以无论是使用`CRDT`算法还是`OT`算法来实现协同，保证最终一致性就是必须要考虑的基本内容。

由于`CRDT`设计上可以完成对于各个副本的合并与更新而不会产生冲突，那么经由`CRDT`实现的算法就可以直接在客户端之间互相传递，相互同步至最终一致性的状态，也就是各个用户之间可以直接`P2P`进行数据合并而不需要中央服务器进行调度，由此`CRDT`可以很好地支持去中心化的应用，即使没有中心化服务器各端之间也能完成同步。

谈到了最终一致性和分布式系统，那么就不得不提到`CAP`理论，`CAP`理论指出在一个分布式系统中，最多只能同时满足`Consistency`(一致性)、`Availability`(可用性)和`Partition Tolerance`(分区容错性)中的两项。

* 一致性`Consistency`: 对于客户端的每次读操作，要么读到的是最新的数据，要么读取失败。换句话说，一致性是站在分布式系统的角度，对访问本系统的客户端的一种承诺：要么我给你返回一个错误，要么我给你返回绝对一致的最新数据，不难看出，其强调的是数据正确。
* 可用性`Availability`: 任何客户端的请求都能得到响应数据，不会出现响应错误。换句话说，可用性是站在分布式系统的角度，对访问本系统的客户的另一种承诺：我一定会给你返回数据，不会给你返回错误，但不保证数据最新，强调的是不出现响应错误。
* 分区容错性`Partition tolerance`:由于分布式系统通过网络进行通信，网络是不可靠的。当任意数量的消息丢失或延迟到达时，系统仍会继续提供服务，不会挂掉。换句话说，分区容忍性是站在分布式系统的角度，对访问本系统的客户端的再一种承诺：我会一直运行，不管我的内部出现何种数据同步问题，强调的是不挂掉。

对于一个分布式系统而言，`P`是前提，必须保证，因为只要有网络交互就一定会有延迟和数据丢失，这种状况我们必须接受，必须保证系统不能挂掉，所以只剩下`C`、`A`可以选择，要么保证数据一致性即数据绝对正确，要么保证可用性即保证响应不出错。首先我们要理解一下为什么`P`是前提，这里的场景是分布式系统，网络是不可靠的，一定会存在网络延迟与丢失等问题，如果不允许存在网络分区也就是说网络是一直保证运行正常的，那么显然每次写入数据都可以进行同步，自然一致性和可用性显然得到了保障，但这也不是分布式系统了。

我们来举个例子，在网络发生问题时，为什么需要在`C`和`A`之间进行选择，假设在分布式系统中存在`100`个节点，但由于故障，使得网络发生了分区，其中有一半的节点无法向另外一半节点通信，于是系统被分割为`A`区与`B`区。在网络分区的情况下，客户端发送请求尝试来对`A`区一个节点进行数据写入，由于`AB`区网络不通，这时候无法同步写入信息给到`B`区节点。在这种场景下，究竟允不允许当前客户端进行数据写入呢。

* 如果允许客户端数据写入，那么当前节点的可用性得到了保证，但是由于网络分区，所以网络不可触达，数据无法同步。因此此时是无法满足一致性，也就是分布式系统中，同时访问两个节点，可能会返回不同数据。
* 如果不允许客户端数据写入，那么当前节点的一致性得到了保证，所有节点数据都是一致的，但是由于数据都无法写入，这时系统显然是不可用的，需要阻塞等待，直到网络连接恢复，也就是可用性无法满足。

实际上`CAP`特性三选二的描述其实具有误导性，从上边的例子中也可以看出，不是在所有时候都只能选择两个特性，在不存在网络失败的情况下即分布式系统正常运行时，`C`和`A`能够同时保证，只有当网络发生分区或失败时，才会在`C`和`A`之间做出选择。作者`Eric Brewer`在`2012`年也发表论文解释了`CAP`实际上只是禁止了设计空间存在分区时的完美可用性和一致性。而实际上在`C`和`A`之间的权衡的设计非常灵活，`CRDT`就是一个很好的例子。`CRDT`算法正是在满足`Partition Tolerance`(分区容错性)的前提下，尽可能地保证`Consistency`(一致性)和`Availability`(可用性)，同样`OT`协同算法也是一样通过保证最终一致性来完成这个权衡的。

在协同编辑的场景下，我们似乎能够同时满足了`CAP`的三个场景限制，假设在网络差的情况下，两个客户端同时提交，虽然暂时一致性无法满足，本地客户端会看到不同的内容，但网络恢复后，通过协同算法数据也能保持一致，这不是既满足了一致性又满足了可用性。这个想法是对的，只是这里我们保证的一致性不等于`CAP`理论的一致性，`CAP`理论是假设在没有网络延迟的情况下的强一致性，也就是数据时刻都是一致的，而协同编辑的场景的一致性则是最终一致性。前文也提到过，在`C`和`A`之间的权衡的设计非常灵活，既然无法做到强一致性`Strong consistency`，那么应用可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性`Eventual consistency`，这个就又需要说到`BASE`理论了。

* `BA`: `Basically Avaliable`，基本可用，允许损失部分可用性，允许牺牲响应时间、降级系统功能等操作。
* `S`: `Soft State`，软状态，允许存在数据中间状态，不要求强一致性，并不影响整体可用性，允许副本之间的数据同步延迟。
* `E`: `Eventually consistency`，最终一致性，所有的副本，在最终都能达到数据一致的状态，但不要求实时的强一致性。

在`BASE`理论中，我们可以看到协同编辑文档的场景中，虽然`CAP`的强一致性无法满足，但通过灵活地设计`C`和`A`，损失部分可用性，允许暂时的客户端不一致情况，通过协同编辑冲突算法，可以解决数据不一致问题，达到了最终的数据一致性。实际上在分布式理论上又有很多研究，有着强一致性、弱一致性、顺序一致性、最终一致性等，而最终一致性也有读写一致性、写读一致性、单调读一致性、单调写一致性等划分，在这里就不再赘述了。

回到协同算法，在了解`CRDT`协同算法之前，我们也可以了解一下`CRDT`协同算法与`OT`协同算法的主要区别。首先`CRDT`与`OT`都提供了最终一致性，这也是协同编辑的最终目标，但是这两种方案达成这一目标的方式不一样：

* `CRDT`无冲突复制数据类型是通过数据结构来做到这一点，`CRDT`有两种实现方式，基于状态的`CvRDT`收敛复制数据类型和基于操作的`CmRDT`可交换复制数据类型。`CvRDT`是将各个副本进行合并，进行多少次合并或以何种顺序进行合并并不重要，所有副本都会收敛。`CmRDT`则具有可交换的操作，因此无需转换操作即可正确应用这些操作。
* `CRDT`更适合分布式系统，可以不需要中央服务器。
* `CRDT`通过数据结构保证了编辑的无冲突，增加了空间复杂度。
* `OT`操作转换则是通过操作`Operation`转换`Transformation`来做到这一点，终端所进行的操作`O`通过网络传输，其他终端在收到操作`O`后需要进行转换`T`，之后才可以应用到文档上，最基础的`OT`是通过转换索引位置以确保收敛。
* `OT`通常必须要有中央服务器进行协同调度。
* `OT`通过算法处理编辑冲突的问题，增加了时间复杂度。


### 基本原理

### 数据结构

### 最后

## 每日一题

```
https://github.com/WindrunnerMax/EveryDay
```

## 参考

```
https://zhuanlan.zhihu.com/p/50990721
https://zhuanlan.zhihu.com/p/510797688
https://zhuanlan.zhihu.com/p/425265438
http://www.alloyteam.com/2020/01/14221/
https://www.jdon.com/artichect/crdt.html
https://www.zhihu.com/question/507425610
https://juejin.cn/post/6844903672032264199
https://juejin.cn/post/7049939780477386759
https://www.zxch3n.com/crdt-intro/design-crdt/
https://hal.inria.fr/file/index/docid/555588/filename/techreport.pdf
https://github.com/Rock-liyi/p2pdb/blob/master/docs/zh-cn/clock/CRDT.md
```
