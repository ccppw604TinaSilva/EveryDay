# 从零实现的浏览器Web脚本
在之前我们介绍了从零实现`Chrome`扩展，而实际上浏览器级别的扩展整体架构非常复杂，尽管当前有统一规范但不同浏览器的具体实现不尽相同，并且成为开发者并上架`Chrome`应用商店需要支付`5$`的注册费，如果我们只是希望在`Web`页面中进行一些轻量级的脚本编写，使用浏览器扩展级别的能力会显得成本略高，所以在本文我们主要探讨浏览器`Web`级别的轻量级脚本实现。

## 描述
在前边的从零实现`Chrome`扩展中，我们使用了`TS`完成了整个扩展的实现，并且使用`Rspack`作为打包工具来构建应用，那么虽然我们实现轻量级脚本是完全可以直接使用`JS`实现的，但是毕竟随着脚本的能力扩展会变得越来越难以维护，所以同样的在这里我们依旧使用`TS`来构建脚本，并且在构建工具上我们可以选择使用`Rollup`来打包脚本，本文涉及的相关的实现可以参考个人实现的脚本集合`https://github.com/WindrunnerMax/TKScript`。

当然浏览器是不支持我们直接编写`Web`级别脚本的，所以我们需要一个运行脚本的基准环境，当前有很多开源的脚本管理器: 

* [GreaseMonkey](https://github.com/greasemonkey/greasemonkey): 俗称油猴，最早的用户脚本管理器，为`Firefox`提供扩展能力，采用`MIT license`协议。
* [TamperMonkey](https://github.com/Tampermonkey/tampermonkey): 俗称篡改猴，最受欢迎的用户脚本管理器，能够为当前主流浏览器提供扩展能力，开源版本采用`GPL-3.0 license`协议。
* [ViolentMonkey](https://github.com/violentmonkey/violentmonkey): 俗称暴力猴，完全开源的用户脚本管理器，同样能够为当前主流浏览器提供扩展能力，采用`MIT license`协议。
* [ScriptCat](https://github.com/scriptscat/scriptcat): 俗称脚本猫，完全开源的用户脚本管理器，同样能够为当前主流浏览器提供扩展能力，采用` GPL-3.0 license`协议。

此外还有很多脚本集合网站，可以用来分享脚本，例如[GreasyFork](https://greasyfork.org/zh-CN/scripts)。在之前我们提到过，在研究浏览器扩展能力之后，可以发现扩展的权限实在是太高了，那么同样的脚本管理器实际上也是通过浏览器扩展来实现的，选择可信的浏览器扩展也是很重要的，例如在上边提到的`TamperMonkey`在早期的版本是开源的，但是在`18`年之后仓库就不再继续更新了，也就是说当前的`TamperMonkey`实际上是一个闭源的扩展，虽然上架谷歌扩展是会有一定的审核，但是毕竟是闭源的，开源对于类似用户脚本管理器这类高级用户工具来说是一个建立信任的信号，所以在选择管理器时也是需要参考的。

脚本管理器实际上依然是基于浏览器扩展来实现的，通过封装浏览器扩展的能力，将部分能力以`API`的形式暴露出来，并且提供给用户脚本权限来应用这些`API`能力，实际上这其中涉及到很多非常有意思的实现，例如脚本中可以访问的`window`与`unsafeWindow`，那么如何实现一个完全隔离的`window`沙箱环境就值的探索，再比如在`Web`页面中是无法跨域访问资源的，如何实现在`Inject Script`中跨域访问资源的通信机制也可以研究一下，所以如果有兴趣的同学可以研究下`ScriptCat`，这是国内的同学开发的脚本管理器，注释都是中文会比较容易阅读。那么本文还是主要关注于应用，我们从最基本的`UserScript`脚本相关能力，到使用`Rollup`来构建脚本，再通过实例来探索脚本的实现来展开本文的讨论。

## UserScript
在最初`GreaseMonkey`油猴实现脚本管理器时，是以`UserScript`作为脚本的`MetaData`也就是元数据块描述，并且还以`GM.`开头提供了诸多高级的`API`使用，例如可跨域的`GM.xmlHttpRequest`，实际上相当于实现了一整套规范，而后期开发的脚本管理器大都会遵循或者兼容这套规范，以便复用相关的生态。其实对于开发者来说这也是个麻烦事，因为我们没有办法控制用户安装的浏览器扩展，而我们的脚本如果用到了某一个扩展单独实现的`API`，那么就会导致脚本在其他扩展中无法使用，特别是将脚本放在脚本平台上之后，没有办法构建渠道包去分发，所以平时还是尽量使用各大扩展都支持的`Meta`与`API`来开发，避免不必要的麻烦。

此外在很久之前我一直好奇在`GreasyFork`上是如何实现用户脚本的安装的，因为实际上我并没有在那个安装脚本的按钮之后发现什么特殊的事件处理，以及如何检测到当前已经安装脚本管理器并且实现通信的，之后简单研究了下发现实际上只要用户脚本是以`.user.js`结尾的文件，就会自动触发脚本管理器的脚本安装功能，并且能够自动记录脚本安装来源，以便在打开浏览器时检查脚本更新，同样的后期这些脚本管理器依然会遵循这套规范，既然我们了解到了脚本的安装原理，在后边实例一节中我会介绍下我个人进行脚本分发的最佳实践。那么在本节，我们主要介绍常见的`Meta`以及`API`的使用。

### Meta

### API

#### unsafeWindow

## 脚本构建
在构建`Chrome`扩展的时候我们是使用`Rspack`来完成的，这次我们换个构建工具使用`Rollup`来打包，主要还是`Rspack`更适合打包整体的`Web`应用，而`Rollup`更适合打包工具类库，我们的`Web`脚本是单文件的脚本，相对来说更适合使用`Rollup`来打包，当然如果想使用`Rspack`来体验`Rust`构建工具的打包速度也是没问题的，甚至也可以直接使用`SWC`来完成打包，实际上在这里我并没有使用`Babel`而是使用`ESBuild`来构建的脚本，速度也是非常不错的。

此外，渠道包

### Rollup

### Meta

## 实例
`DOM`

### CSS

### Event

### 脚本分发

## 每日一题

```
https://github.com/WindrunnerMax/EveryDay
```

## 参考

```
https://en.wikipedia.org/wiki/Greasemonkey
https://wiki.greasespot.net/Metadata_Block
https://wiki.greasespot.net/Greasemonkey_Manual:API
```
