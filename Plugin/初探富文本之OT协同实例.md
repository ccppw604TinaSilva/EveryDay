# 初探富文本之OT协同实例
在前边初探富文本之OT协同算法一文中我们探讨了为什么需要协同、为什么仅有原子化的操作并不能实现协同、为什么要有操作变换、如何进行操作变换、什么时候能够应用操作、服务端如何进行协同调度等等，这些属于完成协同所需要了解的基础知识，实际上当前有很多成熟的协同实现，例如`ot.js`、`ShareDb`、`ot-json`、`EasySync`等等，本文就是以`ShareDb`为`OT`协同框架来实现协同的实例。

## 描述
接入协同框架实际上并不是一件简单的事情，尤其是对于`OT`实现的协同算法而言，`OT`的英文全称是`Operational Transformation`，也就是说实现`OT`的基础就是对内容的描述与操作是`Operational`原子化的。在富文本领域，最经典的`Operation`有`quill`的`delta`模型，通过`retain`、`insert`、`delete`三个操作完成整篇文档的描述，还有`slate`的`JSON`模型，通过`insert_text`、`split_node`、`remove_text`等等操作来完成整篇文档的描述与操作。有了这个协同实现的基础之后，还需要对所有`Op`具体实现变换`Transformation`，这就是个比较麻烦的工作了，而且也是必不可少的实现。同样是以`quill`与`slate`两款开源编辑器为例，在`quill`中已经实现了对于其数据结构`delta`的所有`Transformation`，可以直接调用官方的`quill-delta`包即可；对于`slate`而言，官方只提供了原子化的操作`API`，并没有`Transformation`的具体实现，但是有社区维护的`slate-ot`包实现了其`JSON`数据的`Transformation`，也可以直接调用即可。

`OT`协同的实现在富文本领域有比较多的实现可供参考，特别是在开源的富文本引擎上，其实现方案还是比较成熟的，但是引申一下，在其他领域可能并没有具体的实现，那么就需要参考接入的文档自己实现了。例如我们有一个自研的思维导图功能需要实现协同，而保存的数据结构都是自定义的，没有直接可以调用的实现方案，那么这就需要自己实现操作变换了，对于一个思维导图而言我们实现原子化的操作还是比较容易的，所以我们主要关注于变换的实现。假如这个思维导图功能我们是通过`JSON`的数据结构保存的数据，那么我们就可以参考`json0`或者`slate-ot`的实现，特别是通过阅读单元测试可以比较容易地理解具体的功能，通过参考其实现来自行实现一份`OT`的变换，或者直接依照其实现维护一个中间层的数据结构，依照于这个中间层进行数据转换。再假如我们的思维导入维护的是一个线性的类文本结构，那么就可以参考`rich-text`与`quill-delta`的实现，只不过这样的话实现原子化的操作可能就麻烦一些了，当然同样我们也可以维护一个中间层的数据结构来完成`OT`。实际上有比较多的参考之后，接入`OT`协同就主要是理解并且实现的问题了，这样就有一个大体的实现方向了，而不是毫无头绪不知道应该从哪里开始做协同。另外还是那个宗旨，合适的才是最好的，要考虑到实现的成本问题，没有必要硬套数据结构的实现，就比如上边说的实现思维导图使用线性的文本来表示还是有点牵强的，当然并不是不可能的，比如`Google Docs`的`Table`就是完全的线性结构，要知道其是可以实现表格中嵌套表格的，相当于每一个单元格都是一篇文档，内部可以嵌入任何的富文本结构，而在实现上就是通过线性的结构完成的。

## Counter

## Quill

## 每日一题

```
https://github.com/WindrunnerMax/EveryDay
```

## 参考

```
https://github.com/ottypes/docs
https://share.github.io/sharedb/
https://github.com/share/sharedb
https://www.npmjs.com/package/ot-json0
https://www.npmjs.com/package/ot-json1
https://zhuanlan.zhihu.com/p/425265438
https://www.npmjs.com/package/rich-text
```

